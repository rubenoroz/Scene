{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 52, "column": 0}, "map": {"version":3,"sources":["file:///Users/rubenoroz/scena-v1/src/lib/prisma.ts"],"sourcesContent":["import { PrismaClient } from \"@prisma/client\";\n\n// Optimized for serverless environments (Vercel + Supabase)\nconst prismaClientSingleton = () => {\n  return new PrismaClient({\n    log: process.env.NODE_ENV === 'development' ? ['error', 'warn'] : ['error'],\n    datasources: {\n      db: {\n        url: process.env.DATABASE_URL,\n      },\n    },\n  });\n};\n\ndeclare global {\n  var prisma: undefined | ReturnType<typeof prismaClientSingleton>;\n}\n\nconst prisma = globalThis.prisma ?? prismaClientSingleton();\n\nexport default prisma;\n\nif (process.env.NODE_ENV !== \"production\") globalThis.prisma = prisma;"],"names":[],"mappings":";;;;AAAA;;AAEA,4DAA4D;AAC5D,MAAM,wBAAwB;IAC5B,OAAO,IAAI,6IAAY,CAAC;QACtB,KAAK,uCAAyC;YAAC;YAAS;SAAO,GAAG;QAClE,aAAa;YACX,IAAI;gBACF,KAAK,QAAQ,GAAG,CAAC,YAAY;YAC/B;QACF;IACF;AACF;AAMA,MAAM,SAAS,WAAW,MAAM,IAAI;uCAErB;AAEf,wCAA2C,WAAW,MAAM,GAAG"}},
    {"offset": {"line": 139, "column": 0}, "map": {"version":3,"sources":["file:///Users/rubenoroz/scena-v1/src/lib/auth.ts"],"sourcesContent":["import NextAuth, { getServerSession, AuthOptions } from \"next-auth\"; // Import getServerSession\nimport { PrismaAdapter } from \"@auth/prisma-adapter\";\nimport GitHub from \"next-auth/providers/github\";\nimport CredentialsProvider from \"next-auth/providers/credentials\";\nimport bcrypt from \"bcryptjs\";\nimport prisma from \"@/lib/prisma\"; // Import the singleton Prisma client\n\n// This is your auth configuration\nexport const authOptions: AuthOptions = {\n  adapter: PrismaAdapter(prisma),\n  providers: [\n    GitHub({\n      clientId: process.env.GITHUB_ID ?? \"\",\n      clientSecret: process.env.GITHUB_SECRET ?? \"\",\n    }),\n    CredentialsProvider({\n      name: \"Credentials\",\n      credentials: {\n        email: { label: \"Email\", type: \"text\" },\n        password: { label: \"Password\", type: \"password\" },\n      },\n      async authorize(credentials, req) {\n        if (!credentials?.email || !credentials?.password) {\n          return null;\n        }\n\n        const user = await prisma.user.findUnique({\n          where: {\n            email: credentials.email,\n          },\n        });\n\n        if (!user || !user.hashedPassword) {\n          return null;\n        }\n\n        const isValid = await bcrypt.compare(\n          credentials.password,\n          user.hashedPassword\n        );\n\n        if (isValid) {\n          return user;\n        }\n\n        return null;\n      },\n    }),\n  ],\n  session: {\n    strategy: \"jwt\",\n  },\n  callbacks: {\n    async jwt({ token, user }) {\n      console.log(\"JWT Callback - Token:\", token);\n      console.log(\"JWT Callback - User:\", user);\n      if (user) {\n        token.id = user.id;\n        token.role = user.role; // Assign role from the user object\n      }\n\n      // If the user's role is SUPERADMIN, set isSuperAdmin to true\n      token.isSuperAdmin = token.role === \"SUPERADMIN\";\n\n      return token;\n    },\n    async session({ session, token }) {\n      console.log(\"Session Callback - Session:\", session);\n      console.log(\"Session Callback - Token:\", token);\n      if (session.user) {\n        session.user.id = token.id as string;\n        session.user.role = token.role; // Assign role from the token\n        session.user.isSuperAdmin = token.isSuperAdmin; // Assign isSuperAdmin from the token\n      }\n      return session;\n    },\n    async redirect({ url, baseUrl }) {\n      // Redirect to dashboard after successful login\n      if (url.startsWith(baseUrl)) {\n        return url;\n      }\n      // Default redirect to dashboard\n      return `${baseUrl}/dashboard`;\n    },\n  },\n  pages: {\n    signIn: '/login', // Specify your sign-in page\n  },\n  secret: process.env.NEXTAUTH_SECRET,\n  debug: process.env.NODE_ENV === 'development',\n};\n\n// This is the handler for the [...nextauth] route\n// It's used by app/api/auth/[...nextauth]/route.ts\nexport const { handlers } = NextAuth(authOptions);\n\n// This is the server-side auth helper for NextAuth.js v4 in App Router\nexport async function auth() {\n  return getServerSession(authOptions);\n}\n"],"names":[],"mappings":";;;;;;;;AAAA,6OAAqE,0BAA0B;AAC/F;AACA;AACA;AACA;AACA,8MAAmC,qCAAqC;;;;;;;AAGjE,MAAM,cAA2B;IACtC,SAAS,IAAA,uKAAa,EAAC,iIAAM;IAC7B,WAAW;QACT,IAAA,gKAAM,EAAC;YACL,UAAU,QAAQ,GAAG,CAAC,SAAS,IAAI;YACnC,cAAc,QAAQ,GAAG,CAAC,aAAa,IAAI;QAC7C;QACA,IAAA,qKAAmB,EAAC;YAClB,MAAM;YACN,aAAa;gBACX,OAAO;oBAAE,OAAO;oBAAS,MAAM;gBAAO;gBACtC,UAAU;oBAAE,OAAO;oBAAY,MAAM;gBAAW;YAClD;YACA,MAAM,WAAU,WAAW,EAAE,GAAG;gBAC9B,IAAI,CAAC,aAAa,SAAS,CAAC,aAAa,UAAU;oBACjD,OAAO;gBACT;gBAEA,MAAM,OAAO,MAAM,iIAAM,CAAC,IAAI,CAAC,UAAU,CAAC;oBACxC,OAAO;wBACL,OAAO,YAAY,KAAK;oBAC1B;gBACF;gBAEA,IAAI,CAAC,QAAQ,CAAC,KAAK,cAAc,EAAE;oBACjC,OAAO;gBACT;gBAEA,MAAM,UAAU,MAAM,8IAAM,CAAC,OAAO,CAClC,YAAY,QAAQ,EACpB,KAAK,cAAc;gBAGrB,IAAI,SAAS;oBACX,OAAO;gBACT;gBAEA,OAAO;YACT;QACF;KACD;IACD,SAAS;QACP,UAAU;IACZ;IACA,WAAW;QACT,MAAM,KAAI,EAAE,KAAK,EAAE,IAAI,EAAE;YACvB,QAAQ,GAAG,CAAC,yBAAyB;YACrC,QAAQ,GAAG,CAAC,wBAAwB;YACpC,IAAI,MAAM;gBACR,MAAM,EAAE,GAAG,KAAK,EAAE;gBAClB,MAAM,IAAI,GAAG,KAAK,IAAI,EAAE,mCAAmC;YAC7D;YAEA,6DAA6D;YAC7D,MAAM,YAAY,GAAG,MAAM,IAAI,KAAK;YAEpC,OAAO;QACT;QACA,MAAM,SAAQ,EAAE,OAAO,EAAE,KAAK,EAAE;YAC9B,QAAQ,GAAG,CAAC,+BAA+B;YAC3C,QAAQ,GAAG,CAAC,6BAA6B;YACzC,IAAI,QAAQ,IAAI,EAAE;gBAChB,QAAQ,IAAI,CAAC,EAAE,GAAG,MAAM,EAAE;gBAC1B,QAAQ,IAAI,CAAC,IAAI,GAAG,MAAM,IAAI,EAAE,6BAA6B;gBAC7D,QAAQ,IAAI,CAAC,YAAY,GAAG,MAAM,YAAY,EAAE,qCAAqC;YACvF;YACA,OAAO;QACT;QACA,MAAM,UAAS,EAAE,GAAG,EAAE,OAAO,EAAE;YAC7B,+CAA+C;YAC/C,IAAI,IAAI,UAAU,CAAC,UAAU;gBAC3B,OAAO;YACT;YACA,gCAAgC;YAChC,OAAO,GAAG,QAAQ,UAAU,CAAC;QAC/B;IACF;IACA,OAAO;QACL,QAAQ;IACV;IACA,QAAQ,QAAQ,GAAG,CAAC,eAAe;IACnC,OAAO,oDAAyB;AAClC;AAIO,MAAM,EAAE,QAAQ,EAAE,GAAG,IAAA,kJAAQ,EAAC;AAG9B,eAAe;IACpB,OAAO,IAAA,2JAAgB,EAAC;AAC1B"}},
    {"offset": {"line": 246, "column": 0}, "map": {"version":3,"sources":["file:///Users/rubenoroz/scena-v1/src/lib/permissions.ts"],"sourcesContent":["export const ROLES = {\n    ADMIN: 'ADMIN',\n    PROJECT_MANAGER: 'PROJECT_MANAGER',\n    ARTIST: 'ARTIST',\n    VIEWER: 'VIEWER',\n} as const;\n\nexport type Role = keyof typeof ROLES;\n\nexport const PERMISSIONS = {\n    // Workspace\n    MANAGE_WORKSPACE: ['ADMIN'],\n    CREATE_PROJECT: ['ADMIN', 'PROJECT_MANAGER'],\n    DELETE_PROJECT: ['ADMIN'],\n\n    // Project\n    MANAGE_PROJECT: ['ADMIN', 'PROJECT_MANAGER'],\n    VIEW_PROJECT: ['ADMIN', 'PROJECT_MANAGER', 'ARTIST', 'VIEWER'],\n    MANAGE_ROLES: ['ADMIN', 'PROJECT_MANAGER'],\n\n    // Tasks\n    CREATE_TASK: ['ADMIN', 'PROJECT_MANAGER'],\n    EDIT_ANY_TASK: ['ADMIN', 'PROJECT_MANAGER'],\n    EDIT_OWN_TASK: ['ADMIN', 'PROJECT_MANAGER', 'ARTIST'],\n    MOVE_OWN_TASK: ['ADMIN', 'PROJECT_MANAGER', 'ARTIST'], // Artists can move their own tasks\n    DELETE_TASK: ['ADMIN', 'PROJECT_MANAGER'],\n    ASSIGN_TASK: ['ADMIN', 'PROJECT_MANAGER'],\n\n    // Comments\n    ADD_COMMENT: ['ADMIN', 'PROJECT_MANAGER', 'ARTIST'],\n    DELETE_ANY_COMMENT: ['ADMIN', 'PROJECT_MANAGER'],\n    DELETE_OWN_COMMENT: ['ADMIN', 'PROJECT_MANAGER', 'ARTIST'],\n\n    // Files\n    UPLOAD_FILE: ['ADMIN', 'PROJECT_MANAGER', 'ARTIST'],\n    DELETE_FILE: ['ADMIN', 'PROJECT_MANAGER'],\n} as const;\n\nexport function hasPermission(userRole: string, allowedRoles: readonly string[]): boolean {\n    return allowedRoles.includes(userRole);\n}\n\nimport prisma from \"@/lib/prisma\";\n\nexport async function getUserRoleInProject(userId: string, projectId: string): Promise<string> {\n    // 1. Check direct project role\n    const projectUser = await prisma.projectUser.findUnique({\n        where: {\n            projectId_userId: {\n                projectId,\n                userId,\n            },\n        },\n    });\n\n    if (projectUser) return projectUser.role;\n\n    // 2. Check workspace role (if implemented, workspace admins might have access to all projects)\n    // For now, we'll assume project-level roles are primary. \n    // But we should check if the user is a workspace admin.\n\n    const project = await prisma.project.findUnique({\n        where: { id: projectId },\n        select: { workspaceId: true },\n    });\n\n    if (project) {\n        const workspaceUser = await prisma.workspaceUser.findUnique({\n            where: {\n                workspaceId_userId: {\n                    workspaceId: project.workspaceId,\n                    userId,\n                },\n            },\n        });\n\n        if (workspaceUser && workspaceUser.role === ROLES.ADMIN) {\n            return ROLES.ADMIN;\n        }\n    }\n\n    // Default fallback (e.g., if user is owner of project)\n    const projectOwner = await prisma.project.findUnique({\n        where: { id: projectId },\n        select: { ownerId: true },\n    });\n\n    if (projectOwner && projectOwner.ownerId === userId) {\n        return ROLES.ADMIN;\n    }\n\n    return ROLES.VIEWER; // Default role if found but no specific role assigned? Or maybe null?\n    // For safety, let's return a restricted role or handle \"not found\"\n}\n"],"names":[],"mappings":";;;;;;;;;;AA0CA;AA1CO,MAAM,QAAQ;IACjB,OAAO;IACP,iBAAiB;IACjB,QAAQ;IACR,QAAQ;AACZ;AAIO,MAAM,cAAc;IACvB,YAAY;IACZ,kBAAkB;QAAC;KAAQ;IAC3B,gBAAgB;QAAC;QAAS;KAAkB;IAC5C,gBAAgB;QAAC;KAAQ;IAEzB,UAAU;IACV,gBAAgB;QAAC;QAAS;KAAkB;IAC5C,cAAc;QAAC;QAAS;QAAmB;QAAU;KAAS;IAC9D,cAAc;QAAC;QAAS;KAAkB;IAE1C,QAAQ;IACR,aAAa;QAAC;QAAS;KAAkB;IACzC,eAAe;QAAC;QAAS;KAAkB;IAC3C,eAAe;QAAC;QAAS;QAAmB;KAAS;IACrD,eAAe;QAAC;QAAS;QAAmB;KAAS;IACrD,aAAa;QAAC;QAAS;KAAkB;IACzC,aAAa;QAAC;QAAS;KAAkB;IAEzC,WAAW;IACX,aAAa;QAAC;QAAS;QAAmB;KAAS;IACnD,oBAAoB;QAAC;QAAS;KAAkB;IAChD,oBAAoB;QAAC;QAAS;QAAmB;KAAS;IAE1D,QAAQ;IACR,aAAa;QAAC;QAAS;QAAmB;KAAS;IACnD,aAAa;QAAC;QAAS;KAAkB;AAC7C;AAEO,SAAS,cAAc,QAAgB,EAAE,YAA+B;IAC3E,OAAO,aAAa,QAAQ,CAAC;AACjC;;AAIO,eAAe,qBAAqB,MAAc,EAAE,SAAiB;IACxE,+BAA+B;IAC/B,MAAM,cAAc,MAAM,iIAAM,CAAC,WAAW,CAAC,UAAU,CAAC;QACpD,OAAO;YACH,kBAAkB;gBACd;gBACA;YACJ;QACJ;IACJ;IAEA,IAAI,aAAa,OAAO,YAAY,IAAI;IAExC,+FAA+F;IAC/F,0DAA0D;IAC1D,wDAAwD;IAExD,MAAM,UAAU,MAAM,iIAAM,CAAC,OAAO,CAAC,UAAU,CAAC;QAC5C,OAAO;YAAE,IAAI;QAAU;QACvB,QAAQ;YAAE,aAAa;QAAK;IAChC;IAEA,IAAI,SAAS;QACT,MAAM,gBAAgB,MAAM,iIAAM,CAAC,aAAa,CAAC,UAAU,CAAC;YACxD,OAAO;gBACH,oBAAoB;oBAChB,aAAa,QAAQ,WAAW;oBAChC;gBACJ;YACJ;QACJ;QAEA,IAAI,iBAAiB,cAAc,IAAI,KAAK,MAAM,KAAK,EAAE;YACrD,OAAO,MAAM,KAAK;QACtB;IACJ;IAEA,uDAAuD;IACvD,MAAM,eAAe,MAAM,iIAAM,CAAC,OAAO,CAAC,UAAU,CAAC;QACjD,OAAO;YAAE,IAAI;QAAU;QACvB,QAAQ;YAAE,SAAS;QAAK;IAC5B;IAEA,IAAI,gBAAgB,aAAa,OAAO,KAAK,QAAQ;QACjD,OAAO,MAAM,KAAK;IACtB;IAEA,OAAO,MAAM,MAAM,EAAE,sEAAsE;AAC3F,mEAAmE;AACvE"}},
    {"offset": {"line": 401, "column": 0}, "map": {"version":3,"sources":["file:///Users/rubenoroz/scena-v1/src/app/api/projects/%5BprojectId%5D/tasks/%5BtaskId%5D/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from \"next/server\";\nimport prisma from \"@/lib/prisma\";\nimport { auth } from \"@/lib/auth\";\nimport { getUserRoleInProject, hasPermission, PERMISSIONS } from \"@/lib/permissions\";\n\n// ... GET handler remains unchanged ...\n\n// PUT /api/projects/[projectId]/tasks/[taskId]\nexport async function PUT(\n  req: NextRequest,\n  { params }: { params: Promise<{ projectId: string; taskId: string }> }\n) {\n  try {\n    const session = await auth();\n    if (!session?.user?.id) {\n      return NextResponse.json({ message: \"Unauthorized\" }, { status: 401 });\n    }\n\n    const { projectId, taskId } = await params;\n    const {\n      title,\n      description,\n      columnId,\n      order,\n      parentId,\n      assignees,\n      startDate,\n      endDate,\n      toleranceDate,\n      links,\n      attachments,\n      images,\n      tags,\n      priority,\n      checklist,\n      color,\n      isHiddenInGantt, // Add this\n      progress, // Add progress\n    } = await req.json();\n\n    // First, fetch the current task\n    const currentTask = await prisma.task.findUnique({\n      where: { id: taskId, projectId },\n      include: {\n        children: true,\n        assignees: true\n      },\n    });\n\n    if (!currentTask) {\n      return NextResponse.json({ message: \"Task not found\" }, { status: 404 });\n    }\n\n\n    // Check permissions\n    const userRole = await getUserRoleInProject(session.user.id, projectId);\n    const isOwnTask = currentTask.assignees.some((a: { id: string }) => a.id === session.user.id);\n\n    const canEditAny = hasPermission(userRole, PERMISSIONS.EDIT_ANY_TASK);\n    const canEditOwn = hasPermission(userRole, PERMISSIONS.EDIT_OWN_TASK) && isOwnTask;\n    const canMoveOwn = hasPermission(userRole, PERMISSIONS.MOVE_OWN_TASK) && isOwnTask;\n\n    // Special case: if only moving task (columnId or order), check MOVE_OWN_TASK\n    const isOnlyMoving = (columnId !== undefined || order !== undefined) &&\n      !title && !description && !assignees && !startDate && !endDate &&\n      !toleranceDate && !links && !attachments && !images && !tags &&\n      !priority && !checklist && !color && !isHiddenInGantt && !progress;\n\n    if (isOnlyMoving && !canEditAny && canMoveOwn) {\n      // Allow Artists to move their own tasks\n    } else if (!canEditAny && !canEditOwn) {\n      // If trying to assign users, check ASSIGN_TASK permission specifically\n      if (assignees && !hasPermission(userRole, PERMISSIONS.ASSIGN_TASK)) {\n        return NextResponse.json({ message: \"Forbidden\" }, { status: 403 });\n      }\n      // Otherwise, forbidden\n      if (!assignees) {\n        return NextResponse.json({ message: \"Forbidden\" }, { status: 403 });\n      }\n    }\n\n    // Prepare update data\n    const updateData: any = {};\n    if (title !== undefined) updateData.title = title;\n    if (description !== undefined) updateData.description = description;\n    if (columnId !== undefined) updateData.columnId = columnId;\n    if (order !== undefined) updateData.order = order;\n    if (parentId !== undefined) updateData.parentId = parentId;\n\n    // Handle dates - convert strings to Date objects if needed\n    if (startDate !== undefined) {\n      updateData.startDate = startDate ? new Date(startDate) : null;\n    }\n    if (endDate !== undefined) {\n      updateData.endDate = endDate ? new Date(endDate) : null;\n    }\n    if (toleranceDate !== undefined) {\n      updateData.toleranceDate = toleranceDate ? new Date(toleranceDate) : null;\n    }\n\n    if (links !== undefined) updateData.links = links;\n    if (attachments !== undefined) updateData.attachments = attachments;\n    if (images !== undefined) updateData.images = images;\n    if (tags !== undefined) updateData.tags = tags;\n    if (priority !== undefined) updateData.priority = priority;\n    if (checklist !== undefined) updateData.checklist = checklist;\n    if (color !== undefined) updateData.color = color;\n    if (isHiddenInGantt !== undefined) updateData.isHiddenInGantt = isHiddenInGantt;\n    if (progress !== undefined) updateData.progress = progress;\n\n    // Si solo se envÃ­a color o isHiddenInGantt, permite actualizar solo esos campos\n    if (\n      (Object.keys(updateData).length === 1 && (updateData.color !== undefined || updateData.isHiddenInGantt !== undefined)) &&\n      assignees === undefined\n    ) {\n      const updatedTask = await prisma.task.update({\n        where: { id: taskId, projectId },\n        data: updateData,\n      });\n      return NextResponse.json(updatedTask);\n    }\n\n    let updatedTask;\n\n    // Special handling for moving a parent task\n    const isMovingColumn = columnId && currentTask.columnId !== columnId;\n\n    if (isMovingColumn && currentTask.children.length > 0) {\n      // Use a transaction to move the parent and all its children\n      const [, task] = await prisma.$transaction([\n        prisma.task.updateMany({\n          where: {\n            parentId: taskId,\n          },\n          data: {\n            columnId: columnId,\n          },\n        }),\n        prisma.task.update({\n          where: { id: taskId, projectId },\n          data: {\n            ...updateData,\n            ...(assignees !== undefined && {\n              assignees: {\n                set: assignees.map((id: string) => ({ id })),\n              },\n            }),\n          },\n          include: {\n            children: true, // Re-include children to return the full updated task\n          }\n        }),\n      ]);\n      updatedTask = task;\n    } else {\n      // Standard update for tasks without children or other field updates\n      if (assignees !== undefined) {\n        updatedTask = await prisma.task.update({\n          where: { id: taskId, projectId },\n          data: {\n            ...updateData,\n            assignees: {\n              set: assignees.map((id: string) => ({ id })),\n            },\n          },\n        });\n      } else {\n        updatedTask = await prisma.task.update({\n          where: { id: taskId, projectId },\n          data: updateData,\n        });\n      }\n    }\n\n    // Handle progress aggregation for parent task\n    if (currentTask.parentId) {\n      const parentId = currentTask.parentId;\n\n      // Fetch all siblings to calculate new average\n      const siblings = await prisma.task.findMany({\n        where: { parentId: parentId },\n        select: { progress: true }\n      });\n\n      // Calculate average progress\n      const totalProgress = siblings.reduce((sum: number, task: { progress: number | null }) => sum + (task.progress || 0), 0);\n      const averageProgress = Math.round(totalProgress / siblings.length);\n\n      // Update parent task progress\n      await prisma.task.update({\n        where: { id: parentId },\n        data: { progress: averageProgress }\n      });\n    }\n\n    // Handle cascade completion if progress is 100\n    if (progress === 100) {\n      // Recursive function to get all descendant IDs\n      const getAllDescendantIds = async (taskId: string): Promise<string[]> => {\n        const children = await prisma.task.findMany({\n          where: { parentId: taskId },\n          select: { id: true }\n        });\n\n        if (children.length === 0) return [];\n\n        const childIds = children.map((c: { id: string }) => c.id);\n        const descendantIdsPromises = childIds.map((id: string) => getAllDescendantIds(id));\n        const descendantIdsArrays = await Promise.all(descendantIdsPromises);\n        const descendantIds = descendantIdsArrays.flat();\n\n        return [...childIds, ...descendantIds];\n      };\n\n      const descendantIds = await getAllDescendantIds(taskId);\n\n      if (descendantIds.length > 0) {\n        await prisma.task.updateMany({\n          where: { id: { in: descendantIds } },\n          data: { progress: 100 }\n        });\n      }\n    }\n\n    return NextResponse.json(updatedTask);\n  } catch (error) {\n    console.error(\"Error updating task:\", error);\n    return NextResponse.json(\n      { message: \"Error updating task\" },\n      { status: 500 }\n    );\n  }\n}\n\n// DELETE /api/projects/[projectId]/tasks/[taskId]\nexport async function DELETE(\n  req: NextRequest,\n  { params }: { params: Promise<{ projectId: string; taskId: string }> }\n) {\n  try {\n    const session = await auth();\n    if (!session) {\n      return NextResponse.json({ message: \"Unauthorized\" }, { status: 401 });\n    }\n\n    const { projectId, taskId } = await params;\n\n    // Check permissions\n    const userRole = await getUserRoleInProject(session.user.id, projectId);\n    if (!hasPermission(userRole, PERMISSIONS.DELETE_TASK)) {\n      return NextResponse.json({ message: \"Forbidden\" }, { status: 403 });\n    }\n\n    // Recursive function to delete all descendants\n    async function deleteTaskAndDescendants(taskId: string) {\n      // Get all children\n      const children = await prisma.task.findMany({\n        where: { parentId: taskId },\n        select: { id: true }\n      });\n\n      // Recursively delete children first\n      for (const child of children) {\n        await deleteTaskAndDescendants(child.id);\n      }\n\n      // Delete the task itself\n      await prisma.task.delete({\n        where: { id: taskId },\n      });\n    }\n\n    // Start recursive deletion\n    await deleteTaskAndDescendants(taskId);\n\n    return NextResponse.json({ message: \"Task deleted\" }, { status: 200 });\n  } catch (error) {\n    console.error(\"Error deleting task:\", error);\n    return NextResponse.json(\n      { message: \"Error deleting task\" },\n      { status: 500 }\n    );\n  }\n}"],"names":[],"mappings":"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"}}]
}